<?php

namespace App\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * UserRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UserRepository extends EntityRepository
{
    public function getTotalShoppers(\DateTime $start, \DateTime $end)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('u');
        $qb->select('COUNT(DISTINCT u)');
        $qb->join('u.payables', 'p', 'WITH',
            $qb->expr()->andx(
                'p INSTANCE OF App\Entity\Cashback',
                'p.status <> :invalid'
            )
        )->setParameter('invalid', Payable::STATUS_INVALID);
        $qb->where('p.registeredAt >= :after')->setParameter('after', $start);
        $qb->andWhere('p.registeredAt < :before')->setParameter('before', $before);

        return $qb->getQuery()->getSingleScalarResult();
    }

    public function getTotalNewUsers(\DateTime $start, \DateTime $end)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('u');
        $qb->select('COUNT(u)');
        $qb->where('u.createdAt >= :after')->setParameter('after', $start);
        $qb->andWhere('u.createdAt < :before')->setParameter('before', $before);

        return $qb->getQuery()->getSingleScalarResult();
    }

    public function getTotalReferrers(\DateTime $start, \DateTime $end)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('u');
        $qb->select('COUNT(DISTINCT u)');
        $qb->join('u.referredUsers', 'r', 'WITH', $qb->expr()->andx('r.createdAt >= :after', 'r.createdAt < :before'));
        $qb->setParameter('after', $start);
        $qb->setParameter('before', $before);

        return $qb->getQuery()->getSingleScalarResult();
    }

    protected function getCommissionStats(\DateTime $start, \DateTime $end, $type = 'commission', array $users = null)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        if (!in_array($type, ['commission', 'cashback', 'referral'])) {
            throw new \Exception('Invalid type');
        }

        $qb = $this->createQueryBuilder('u');
        switch ($type) {
            case 'commission' :
                $qb->join('u.payables', 'p', 'WITH',
                    $qb->expr()->andx(
                        $qb->expr()->orx(
                            'p INSTANCE OF App\Entity\Cashback',
                            'p INSTANCE OF App\Entity\Referral'
                        ),
                        'p.status <> :invalid'
                    )
                )->setParameter(':invalid', Payable::STATUS_INVALID);
                break;
            case 'cashback' :
                $qb->join('u.payables', 'p', 'WITH',
                    $qb->expr()->andx(
                        'p INSTANCE OF App\Entity\Cashback',
                        'p.status <> :invalid'
                    )
                )->setParameter(':invalid', Payable::STATUS_INVALID);
                break;
            case 'referral' :
                $qb->join('u.payables', 'p', 'WITH',
                    $qb->expr()->andx(
                        'p INSTANCE OF App\Entity\Referral',
                        'p.status <> :invalid'
                    )
                )->setParameter(':invalid', Payable::STATUS_INVALID);
                break;
        }
        $qb->addSelect('SUM(p.amount) AS total');
        $qb->where('p.registeredAt >= :after')->setParameter('after', $start);
        $qb->andWhere('p.registeredAt < :before')->setParameter('before', $before);
        $qb->groupBy('u');
        if (count($users) > 0) {
            // return users in parameter
            $qb->andWhere('u IN (:users)')->setParameter('users', $users);
        }
        $qb->orderBy('u.id'); // order by id to merge results easily

        return $qb->getQuery()->getResult();
    }

    public function getTransactionStats(\DateTime $start, \DateTime $end, array $users = null)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        // this query uses Cashback as root entity
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select('c')->from('App\Entity\Cashback', 'c');
        $qb->join('c.user', 'u', 'WITH', 'c.status <> :invalid');
        $qb->setParameter('invalid', Cashback::STATUS_INVALID);
        $qb->join('c.transactions', 't', 'WITH', 't.status <> :canceled');
        $qb->setParameter('canceled', Transaction::STATUS_CANCELED);

        $qb->addSelect('u');
        $qb->addSelect('SUM(t.total) AS total');
        $qb->where('c.registeredAt >= :after')->setParameter('after', $start);
        $qb->andWhere('c.registeredAt < :before')->setParameter('before', $before);
        $qb->groupBy('c');
        $qb->groupBy('t');
        $qb->having('total > 0');
        if (count($users) > 0) {
            // return users in parameter
            $qb->andWhere('u IN (?3)')->setParameter(3, $users);
        }
        $qb->orderBy('u.id'); // order by id to merge results easily

        $rows = $qb->getQuery()->getResult();

        // build result as if user were the root entity
        $result = [];

        // rows is ordered by user id
        $i = 0;
        foreach ($rows as $row) {
            $user = $row[0]->getUser();
            // first pass, or current result not for the same user, increment i
            if ($i === 0 || $result[$i][0] !== $user) {
                $i++;
            }
            // initialize new result
            if (!isset($result[$i])) {
                $result[$i] = [0 => $user, 'total' => 0.00];
            }
            // sum total
            $result[$i]['total'] += $row['total'];
        }

        return $result;
    }

    public function getNetworkStats(\DateTime $start, \DateTime $end, array $users = null)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('level0');
        $qb->leftJoin('level0.referredUsers', 'level1', 'WITH', $qb->expr()->andx('level1.createdAt >= :after', 'level1.createdAt < :before'));
        $qb->leftJoin('level1.referredUsers', 'level2', 'WITH', $qb->expr()->andx('level2.createdAt >= :after', 'level2.createdAt < :before'));
        $qb->leftJoin('level2.referredUsers', 'level3', 'WITH', $qb->expr()->andx('level3.createdAt >= :after', 'level3.createdAt < :before'));
        $qb->leftJoin('level3.referredUsers', 'level4', 'WITH', $qb->expr()->andx('level4.createdAt >= :after', 'level4.createdAt < :before'));
        $qb->leftJoin('level4.referredUsers', 'level5', 'WITH', $qb->expr()->andx('level5.createdAt >= :after', 'level5.createdAt < :before'));
        $qb->leftJoin('level5.referredUsers', 'level6', 'WITH', $qb->expr()->andx('level6.createdAt >= :after', 'level6.createdAt < :before'));
        $qb->leftJoin('level6.referredUsers', 'level7', 'WITH', $qb->expr()->andx('level7.createdAt >= :after', 'level7.createdAt < :before'));
        $qb->addSelect('COUNT(level1) + COUNT(level2) + COUNT(level3) + COUNT(level4) + COUNT(level5) + COUNT(level6) + COUNT(level7) AS total');
        $qb->setParameter('after', $start);
        $qb->setParameter('before', $before);
        $qb->groupBy('level0');
        $qb->having('total > 0');
        if (count($users) > 0) {
            // return users in parameter
            $qb->andWhere('level0 IN (:users)')->setParameter('users', $users);
        }
        $qb->orderBy('level0.id'); // order by id to merge results easily

        return $qb->getQuery()->getResult();
    }

    public function getDirectNetworkStats(\DateTime $start, \DateTime $end, array $users = null)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('level0');
        $qb->join('level0.referredUsers', 'level1', 'WITH', $qb->expr()->andx('level1.createdAt >= :after', 'level1.createdAt < :before'));
        $qb->addSelect('COUNT(level1) AS total');
        $qb->setParameter('after', $start);
        $qb->setParameter('before', $before);
        $qb->groupBy('level0');
        if (count($users) > 0) {
            // return users in parameter
            $qb->andWhere('level0 IN (:users)')->setParameter('users', $users);
        }
        $qb->orderBy('level0.id'); // order by id to merge results easily

        return $qb->getQuery()->getResult();
    }

    public function getTopUsers(\DateTime $start, \DateTime $end)
    {
        $topCommission = $this->getCommissionStats($start, $end);

        $users = array_map(function ($result) {
            return $result[0];
        }, $topCommission);

        $topCashback = $this->getCommissionStats($start, $end, 'cashback', $users);
        $topReferral = $this->getCommissionStats($start, $end, 'referral', $users);
        $topTransaction = $this->getTransactionStats($start, $end, $users);
        $topNetwork = $this->getNetworkStats($start, $end, $users);
        $topDirectNetwork = $this->getDirectNetworkStats($start, $end, $users);

        // array must be ordered by user id
        $finder = function (&$arr, $user, $default) {
            $row = current($arr);
            while (false !== $row && $row[0]->getId() < $user->getId()) {
                $row = next($arr);
            }
            if ($row[0] === $user) {
                return $row['total'];
            }
            return $default;
        };

        $topUsers = [];
        foreach ($topCommission as $data) {
            $user = $data[0];

            $topUsers[] = [
                0 => $user,
                'commission' => $data['total'],
                'cashback' => $finder($topCashback, $user, 0),
                'referral' => $finder($topReferral, $user, 0),
                'transaction' => $finder($topTransaction, $user, 0),
                'network' => $finder($topNetwork, $user, 0),
                'direct' => $finder($topDirectNetwork, $user, 0),
                'payment' => 0.00,
                'taxable' => 0.00,
            ];
        }

        usort($topUsers, function ($row1, $row2) {
            $value1 = floor($row1['commission'] * 100);
            $value2 = floor($row2['commission'] * 100);
            $id1 = $row1[0]->getId();
            $id2 = $row2[0]->getId();

            if ($value1 === $value2) {
                return ($id1 < $id2) ? 1 : -1; // descending order
            }
            return ($value1 < $value2) ? 1 : -1; // descending order
        });

        return $topUsers;
    }
}
