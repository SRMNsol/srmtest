<?php

namespace App\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * UserRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UserRepository extends EntityRepository
{
    public function getTotalShoppers(\DateTime $start, \DateTime $end)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('u');
        $qb->select('COUNT(DISTINCT u)');
        $qb->join('u.payables', 'p', 'WITH',
            $qb->expr()->andx(
                'p INSTANCE OF App\Entity\Cashback',
                'p.status <> :invalid'
            )
        )->setParameter('invalid', Payable::STATUS_INVALID);
        $qb->where('p.registeredAt >= :after')->setParameter('after', $start);
        $qb->andWhere('p.registeredAt < :before')->setParameter('before', $before);

        return $qb->getQuery()->getSingleScalarResult();
    }

    public function getTotalNewUsers(\DateTime $start, \DateTime $end)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('u');
        $qb->select('COUNT(u)');
        $qb->where('u.status <> :inactive')->setParameter('inactive', User::STATUS_INACTIVE);
        $qb->andWhere('u.createdAt >= :after')->setParameter('after', $start);
        $qb->andWhere('u.createdAt < :before')->setParameter('before', $before);

        return $qb->getQuery()->getSingleScalarResult();
    }

    public function getTotalReferrers(\DateTime $start, \DateTime $end)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        $qb = $this->createQueryBuilder('u');
        $qb->select('COUNT(DISTINCT u)');
        $qb->join('u.referredUsers', 'r', 'WITH', 'r.status <> :inactive');
        $qb->setParameter('inactive', User::STATUS_INACTIVE);
        $qb->where('r.createdAt >= :after')->setParameter('after', $start);
        $qb->andWhere('r.createdAt < :before')->setParameter('before', $before);

        return $qb->getQuery()->getSingleScalarResult();
    }

    protected function getCommissionStats(\DateTime $start, \DateTime $end, $type = 'commission', array $users = null)
    {
        $before = clone $end;
        $before->add(\DateInterval::createFromDateString('+1 day'));

        if (!in_array($type, ['commission', 'cashback', 'referral'])) {
            throw new \Exception('Invalid type');
        }

        $qb = $this->createQueryBuilder('u');
        switch ($type) {
            case 'commission' :
                $qb->join('u.payables', 'p', 'WITH',
                    $qb->expr()->andx(
                        $qb->expr()->orx(
                            'p INSTANCE OF App\Entity\Cashback',
                            'p INSTANCE OF App\Entity\Referral'
                        ),
                        'p.status <> :invalid'
                    )
                )->setParameter(':invalid', Payable::STATUS_INVALID);
                break;
            case 'cashback' :
                $qb->join('u.payables', 'p', 'WITH',
                    $qb->expr()->andx(
                        'p INSTANCE OF App\Entity\Cashback',
                        'p.status <> :invalid'
                    )
                )->setParameter(':invalid', Payable::STATUS_INVALID);
                break;
            case 'referral' :
                $qb->join('u.payables', 'p', 'WITH',
                    $qb->expr()->andx(
                        'p INSTANCE OF App\Entity\Referral',
                        'p.status <> :invalid'
                    )
                )->setParameter(':invalid', Payable::STATUS_INVALID);
                break;
        }
        $qb->addSelect('SUM(p.amount) AS total');
        $qb->where('p.registeredAt >= :after')->setParameter('after', $start);
        $qb->andWhere('p.registeredAt < :before')->setParameter('before', $before);
        $qb->groupBy('u.id');
        if (count($users) > 0) {
            // return users in parameter
            $qb->andWhere('u IN (?3)')->setParameter(3, $users);
        }
        $qb->orderBy('u.id'); // order by id to merge results easily

        return $qb->getQuery()->getResult();
    }

    public function getTopUsers(\DateTime $start, \DateTime $end)
    {
        $topCommission = $this->getCommissionStats($start, $end);

        $users = array_map(function ($result) {
            return $result[0];
        }, $topCommission);

        $topCashback = $this->getCommissionStats($start, $end, 'cashback', $users);
        $topReferral = $this->getCommissionStats($start, $end, 'referral', $users);
        $topTransaction = $this->getEntityManager()->getRepository('App\Entity\Cashback')->getTransactionStats($start, $end, $users);

        // array must be ordered by user id
        $finder = function (&$arr, $user, $default) {
            $row = current($arr);
            while (false !== $row && $row[0]->getId() < $user->getId()) {
                $row = next($arr);
            }
            if ($row[0] === $user) {
                return $row['total'];
            }
            return $default;
        };

        $topUsers = [];
        foreach ($topCommission as $data) {
            $user = $data[0];

            $topUsers[] = [
                0 => $user,
                'commission' => $data['total'],
                'cashback' => $finder($topCashback, $user, 0),
                'referral' => $finder($topReferral, $user, 0),
                'transaction' => $finder($topTransaction, $user, 0),
            ];
        }

        usort($topUsers, function ($row1, $row2) {
            $value1 = floor($row1['commission'] * 100);
            $value2 = floor($row2['commission'] * 100);
            $id1 = $row1[0]->getId();
            $id2 = $row2[0]->getId();

            if ($value1 === $value2) {
                return ($id1 < $id2) ? 1 : -1; // descending order
            }
            return ($value1 < $value2) ? 1 : -1; // descending order
        });

        return $topUsers;
    }
}
